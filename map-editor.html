<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <title>ğŸ—ºï¸ åœ°å›¾ç¼–è¾‘å™¨ Â· é­”é“å¡”é˜²</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      background: #0d0f14;
      color: #f0f0f0;
      font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    /* â”€â”€ é¡¶éƒ¨å·¥å…·æ  â”€â”€ */
    #toolbar {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px 14px;
      background: #161a22;
      border-bottom: 1px solid #252b38;
      flex-shrink: 0;
      flex-wrap: wrap;
    }
    #toolbar-title { font-size: 15px; font-weight: 700; color: #6fe3ff; white-space: nowrap; }

    select {
      background: #1e2330;
      color: #f0f0f0;
      border: 1px solid #3a4050;
      border-radius: 6px;
      padding: 5px 10px;
      font-size: 13px;
      cursor: pointer;
    }

    .sep { width: 1px; height: 24px; background: #2a2f3b; }

    .brush-btn {
      padding: 5px 12px;
      border: 2px solid transparent;
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
      font-weight: 600;
      transition: all 0.12s;
      background: none;
      color: #ccc;
    }
    .brush-btn[data-brush="1"] { border-color: rgba(255,80,80,0.4); color: #ff8888; }
    .brush-btn[data-brush="2"] { border-color: rgba(80,220,120,0.4); color: #5edc7a; }
    .brush-btn[data-brush="0"] { border-color: rgba(200,160,80,0.4); color: #ffc060; }
    .brush-btn.active { filter: brightness(1.5); box-shadow: 0 0 10px currentColor; }
    .brush-btn[data-brush="1"].active { background: rgba(255,60,60,0.15); }
    .brush-btn[data-brush="2"].active { background: rgba(60,220,100,0.15); }
    .brush-btn[data-brush="0"].active { background: rgba(200,160,80,0.15); }

    .action-btn {
      padding: 5px 12px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
      font-weight: 600;
      background: #2c3a55;
      color: #d0e0ff;
      transition: background 0.12s;
    }
    .action-btn:hover { background: #3a4f70; }
    .action-btn.success { background: #1a5c36; color: #5edc7a; }
    .action-btn.success:hover { background: #236b41; }
    .action-btn.danger { background: #5c1a1a; color: #ff6060; }
    .action-btn.danger:hover { background: #6b2323; }

    #coord-display {
      margin-left: auto;
      font-size: 12px;
      color: #6a7a9a;
      font-family: monospace;
      white-space: nowrap;
    }

    /* â”€â”€ ä¸»ç¼–è¾‘åŒº â”€â”€ */
    #editor-area {
      flex: 1;
      display: flex;
      overflow: hidden;
    }

    #canvas-wrap {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 8px;
      overflow: hidden;
      background: #0a0c10;
    }

    #map-canvas {
      cursor: crosshair;
      max-width: 100%;
      max-height: 100%;
      display: block;
      border: 1px solid #252b38;
    }

    /* â”€â”€ å³ä¾§è¾“å‡ºæ  â”€â”€ */
    #output-panel {
      width: 270px;
      flex-shrink: 0;
      background: #161a22;
      border-left: 1px solid #252b38;
      display: flex;
      flex-direction: column;
      padding: 12px;
      gap: 8px;
      overflow: hidden;
    }

    #legend {
      background: #0d0f14;
      border-radius: 6px;
      padding: 8px 10px;
      display: flex;
      flex-direction: column;
      gap: 5px;
      font-size: 12px;
      color: #9ca7c6;
      flex-shrink: 0;
    }
    .legend-row { display: flex; align-items: center; gap: 8px; }
    .legend-dot {
      width: 16px; height: 16px; border-radius: 3px; flex-shrink: 0;
    }

    #output-panel h3 {
      font-size: 12px;
      color: #6a7a9a;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      flex-shrink: 0;
    }

    #json-output {
      flex: 1;
      background: #0a0c10;
      color: #3ecf8e;
      border: 1px solid #252b38;
      border-radius: 6px;
      padding: 8px;
      font-family: 'Consolas', 'Courier New', monospace;
      font-size: 11px;
      resize: none;
      outline: none;
      min-height: 0;
    }

    #copy-status {
      font-size: 12px;
      color: #3ecf8e;
      height: 16px;
      text-align: center;
      flex-shrink: 0;
    }

    #path-info {
      font-size: 11px;
      color: #6a7a9a;
      background: #0d0f14;
      border-radius: 4px;
      padding: 6px 8px;
      flex-shrink: 0;
    }
  </style>
</head>
<body>

<div id="toolbar">
  <span id="toolbar-title">ğŸ—ºï¸ åœ°å›¾ç¼–è¾‘å™¨</span>
  <select id="level-select"><option value="">â”€â”€ é€‰æ‹©å…³å¡ â”€â”€</option></select>
  <div class="sep"></div>
  <button class="brush-btn active" data-brush="1">ğŸ”´ æ•Œäººè·¯å¾„</button>
  <button class="brush-btn" data-brush="2">ğŸŸ¢ æ”¾å¡”ä½ç½®</button>
  <button class="brush-btn" data-brush="0">â¬œ æ©¡çš®æ“¦</button>
  <div class="sep"></div>
  <button class="action-btn danger" id="clear-btn">ğŸ—‘ æ¸…ç©º</button>
  <button class="action-btn success" id="export-btn">ğŸ“‹ ç”Ÿæˆ JSON</button>
  <span id="coord-display">x:- y:-</span>
</div>

<div id="editor-area">
  <div id="canvas-wrap">
    <canvas id="map-canvas"></canvas>
  </div>
  <div id="output-panel">
    <div id="legend">
      <div class="legend-row"><div class="legend-dot" style="background:rgba(255,60,60,0.75)"></div>æ•Œäººè·¯å¾„ï¼ˆæ•°å­—=é¡ºåºï¼‰</div>
      <div class="legend-row"><div class="legend-dot" style="background:rgba(60,220,100,0.65)"></div>å¯æ”¾å¡”ä½ç½®</div>
      <div class="legend-row"><div class="legend-dot" style="background:rgba(255,255,255,0.08);border:1px solid #333"></div>ç©ºæ ¼=æ™®é€šåœ°å½¢</div>
    </div>
    <div id="path-info">è·¯å¾„æ ¼å­ï¼š<span id="path-count">0</span> ä¸ª &nbsp;|&nbsp; å¡”ä½ï¼š<span id="tower-count">0</span> ä¸ª</div>
    <h3>ğŸ“„ JSON è¾“å‡º</h3>
    <textarea id="json-output" readonly placeholder="ç‚¹å‡»ã€Œç”Ÿæˆ JSONã€ååœ¨æ­¤æ˜¾ç¤º..."></textarea>
    <button class="action-btn success" id="copy-btn">ğŸ“‹ å¤åˆ¶åˆ°å‰ªè´´æ¿</button>
    <div id="copy-status"></div>
  </div>
</div>

<script type="module">
import { campaigns } from './src/levels/campaigns.js';
import { chapterBackgrounds, gridWidth, gridHeight } from './src/config.js';

// â”€â”€ å¸¸é‡ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const GRID_W = gridWidth;   // 32
const GRID_H = gridHeight;  // 18
const CELL_PX = 40;         // canvas å†…æ¯æ ¼åƒç´ 
const CW = GRID_W * CELL_PX; // 1280
const CH = GRID_H * CELL_PX; // 720

// â”€â”€ Canvas åˆå§‹åŒ– â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const canvas = document.getElementById('map-canvas');
const ctx = canvas.getContext('2d');
canvas.width = CW;
canvas.height = CH;

// â”€â”€ çŠ¶æ€ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let grid = newGrid();           // grid[y][x] = 0|1|2
let brush = 1;                  // å½“å‰ç¬”åˆ·ï¼š1=è·¯å¾„ 2=å¡”ä½ 0=æ©¡çš®
let isDrawing = false;
let hoverCell = null;
let bgImage = null;
let currentLevel = null;

function newGrid() {
  return Array.from({ length: GRID_H }, () => new Uint8Array(GRID_W));
}

// â”€â”€ å…³å¡é€‰æ‹©å™¨å¡«å…… â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const sel = document.getElementById('level-select');
campaigns.forEach(c => {
  const grp = document.createElement('optgroup');
  grp.label = `ç¬¬${c.id}ç«  ${c.name}`;
  c.levels.forEach(lv => {
    const opt = document.createElement('option');
    opt.value = `${c.id}:${lv.id}`;
    opt.textContent = `${lv.id} ${lv.name}`;
    grp.appendChild(opt);
  });
  sel.appendChild(grp);
});

sel.addEventListener('change', () => {
  const [cId, lvId] = sel.value.split(':');
  if (!cId) return;
  const campaign = campaigns.find(c => c.id === parseInt(cId));
  const level = campaign?.levels.find(l => l.id === lvId);
  if (!level) return;
  currentLevel = level;
  loadLevel(campaign, level);
});

// â”€â”€ åŠ è½½å…³å¡ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function loadLevel(campaign, level) {
  grid = newGrid();

  // ä» pathNodes æ¢å¤ç°æœ‰è·¯å¾„
  if (level.pathNodes?.length > 1) {
    const nodes = level.pathNodes;
    for (let i = 0; i < nodes.length - 1; i++) {
      let { x, y } = nodes[i];
      const ex = nodes[i + 1].x, ey = nodes[i + 1].y;
      const sx = Math.sign(ex - x), sy = Math.sign(ey - y);
      if (i === 0) setCell(x, y, 1);
      while (x !== ex || y !== ey) {
        x += sx; y += sy;
        setCell(x, y, 1);
      }
    }
  }

  // åŠ è½½èƒŒæ™¯å›¾
  bgImage = null;
  const bgUrl = chapterBackgrounds[campaign.id];
  if (bgUrl) {
    const img = new Image();
    img.onload = () => { bgImage = img; render(); };
    img.src = bgUrl;
  } else {
    render();
  }
}

function setCell(x, y, type) {
  if (x >= 0 && x < GRID_W && y >= 0 && y < GRID_H) grid[y][x] = type;
}

// â”€â”€ è·¯å¾„è¿½è¸ªï¼ˆä»æœ€å·¦ä¾§è·¯å¾„æ ¼å‡ºå‘ï¼Œé¡ºåºè¿½è¸ªï¼‰ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function tracePathCells() {
  const cells = [];
  for (let y = 0; y < GRID_H; y++)
    for (let x = 0; x < GRID_W; x++)
      if (grid[y][x] === 1) cells.push([x, y]);
  if (!cells.length) return [];

  const pathSet = new Set(cells.map(([x, y]) => `${x},${y}`));

  // æ‰¾èµ·ç‚¹ï¼šx=0 ä¸Šçš„è·¯å¾„æ ¼ï¼Œæˆ–æœ€å° x çš„è·¯å¾„æ ¼
  let start = cells.find(([x]) => x === 0);
  if (!start) start = cells.reduce((a, b) => a[0] < b[0] ? a : b);

  const visited = new Set();
  const ordered = [];
  let cur = start;
  let prevDir = [1, 0];

  while (cur) {
    const [x, y] = cur;
    const key = `${x},${y}`;
    if (visited.has(key)) break;
    visited.add(key);
    ordered.push([x, y]);

    const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
    // åŒæ–¹å‘ä¼˜å…ˆ
    dirs.sort((a, b) => {
      const am = a[0]===prevDir[0] && a[1]===prevDir[1] ? -1 : 0;
      const bm = b[0]===prevDir[0] && b[1]===prevDir[1] ? -1 : 0;
      return am - bm;
    });

    let next = null;
    for (const [dx, dy] of dirs) {
      const nk = `${x+dx},${y+dy}`;
      if (pathSet.has(nk) && !visited.has(nk)) {
        next = [x+dx, y+dy];
        prevDir = [dx, dy];
        break;
      }
    }
    cur = next;
  }
  return ordered;
}

// è·¯å¾„æ ¼ â†’ ç®€åŒ– waypointsï¼ˆä»…ä¿ç•™è½¬æŠ˜ç‚¹ï¼‰
function toWaypoints(ordered) {
  if (!ordered.length) return [];
  const wps = [ordered[0]];
  let prevDir = null;

  for (let i = 1; i < ordered.length; i++) {
    const dir = `${ordered[i][0]-ordered[i-1][0]},${ordered[i][1]-ordered[i-1][1]}`;
    if (prevDir !== null && dir !== prevDir) {
      wps.push(ordered[i-1]);
    }
    prevDir = dir;
    if (i === ordered.length - 1) wps.push(ordered[i]);
  }

  // å»é‡è¿ç»­ç›¸åŒ
  return wps.filter((w, i) => i === 0 || w[0] !== wps[i-1][0] || w[1] !== wps[i-1][1]);
}

// â”€â”€ æ¸²æŸ“ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function render() {
  // åº•è‰²
  ctx.fillStyle = '#1a1f2e';
  ctx.fillRect(0, 0, CW, CH);

  // èƒŒæ™¯å›¾
  if (bgImage) {
    ctx.drawImage(bgImage, 0, 0, CW, CH);
  }

  // è¿½è¸ªè·¯å¾„ï¼ˆä¸ºç®­å¤´å’Œåºå·åšå‡†å¤‡ï¼‰
  const traced = tracePathCells();
  const traceIndex = new Map(traced.map(([x,y], i) => [`${x},${y}`, i]));

  // ç»˜åˆ¶æ ¼å­å è‰²
  for (let y = 0; y < GRID_H; y++) {
    for (let x = 0; x < GRID_W; x++) {
      const t = grid[y][x];
      if (!t) continue;
      const px = x * CELL_PX, py = y * CELL_H_PX();
      if (t === 1) {
        ctx.fillStyle = 'rgba(220,50,50,0.42)';
      } else {
        ctx.fillStyle = 'rgba(50,200,80,0.42)';
      }
      ctx.fillRect(px, py, CELL_PX, CELL_H_PX());
    }
  }

  // è·¯å¾„ç®­å¤´ï¼ˆæ¯æ ¼ä¸­å¿ƒç”»æ–¹å‘ç®­å¤´ï¼‰
  for (let i = 0; i < traced.length; i++) {
    const [x, y] = traced[i];
    const cx = x * CELL_PX + CELL_PX / 2;
    const cy = y * CELL_H_PX() + CELL_H_PX() / 2;

    // åºå·ï¼ˆè¾ƒå¤§é—´éš”æ˜¾ç¤ºï¼‰
    const idx = i + 1;
    if (i === 0 || i === traced.length - 1 || idx % 5 === 0) {
      ctx.fillStyle = 'rgba(255,220,80,0.95)';
      ctx.font = `bold ${Math.min(CELL_PX, CELL_H_PX()) * 0.45}px monospace`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(idx, cx, cy);
    } else if (i < traced.length - 1) {
      // å°ç®­å¤´
      const [nx, ny] = traced[i+1];
      const dx = nx - x, dy = ny - y;
      const angle = Math.atan2(dy * CELL_H_PX(), dx * CELL_PX);
      const s = Math.min(CELL_PX, CELL_H_PX()) * 0.22;
      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(angle);
      ctx.fillStyle = 'rgba(255,220,80,0.7)';
      ctx.beginPath();
      ctx.moveTo(s, 0);
      ctx.lineTo(-s * 0.6, -s * 0.5);
      ctx.lineTo(-s * 0.6, s * 0.5);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }
  }

  // å¡”ä½æ ‡è®°ï¼ˆåœ†åœˆï¼‰
  for (let y = 0; y < GRID_H; y++) {
    for (let x = 0; x < GRID_W; x++) {
      if (grid[y][x] !== 2) continue;
      const cx = x * CELL_PX + CELL_PX/2;
      const cy = y * CELL_H_PX() + CELL_H_PX()/2;
      const r = Math.min(CELL_PX, CELL_H_PX()) * 0.38;
      ctx.strokeStyle = 'rgba(80,240,120,0.9)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(cx, cy, r, 0, Math.PI*2);
      ctx.stroke();
    }
  }

  // ç½‘æ ¼çº¿
  ctx.strokeStyle = 'rgba(255,255,255,0.07)';
  ctx.lineWidth = 0.5;
  for (let x = 0; x <= GRID_W; x++) {
    ctx.beginPath();
    ctx.moveTo(x * CELL_PX, 0);
    ctx.lineTo(x * CELL_PX, CH);
    ctx.stroke();
  }
  for (let y = 0; y <= GRID_H; y++) {
    ctx.beginPath();
    ctx.moveTo(0, y * CELL_H_PX());
    ctx.lineTo(CW, y * CELL_H_PX());
    ctx.stroke();
  }

  // æ‚¬åœé«˜äº®
  if (hoverCell) {
    const [hx, hy] = hoverCell;
    ctx.strokeStyle = 'rgba(255,255,255,0.6)';
    ctx.lineWidth = 2;
    ctx.strokeRect(hx * CELL_PX + 1, hy * CELL_H_PX() + 1, CELL_PX - 2, CELL_H_PX() - 2);
  }

  // æ›´æ–°è®¡æ•°
  let pathCnt = 0, towerCnt = 0;
  for (let y = 0; y < GRID_H; y++)
    for (let x = 0; x < GRID_W; x++) {
      if (grid[y][x] === 1) pathCnt++;
      else if (grid[y][x] === 2) towerCnt++;
    }
  document.getElementById('path-count').textContent = pathCnt;
  document.getElementById('tower-count').textContent = towerCnt;
}

// å›  canvas æ˜¯æ­£æ–¹æ ¼å­ï¼ˆå®½=é«˜=CELL_PXï¼‰ï¼Œä½† grid æ˜¯ 32Ã—18ï¼Œ
// å‚ç›´æ–¹å‘éœ€è¦æŒ‰æ¯”ä¾‹ï¼šCH/GRID_H
function CELL_H_PX() { return CH / GRID_H; } // = 40ï¼Œä¸ CELL_PX ç›¸åŒï¼Œso each cell is 40x40

// â”€â”€ é¼ æ ‡äº‹ä»¶ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function getCellFromEvent(e) {
  const rect = canvas.getBoundingClientRect();
  const scaleX = CW / rect.width;
  const scaleY = CH / rect.height;
  const px = (e.clientX - rect.left) * scaleX;
  const py = (e.clientY - rect.top) * scaleY;
  const x = Math.floor(px / CELL_PX);
  const y = Math.floor(py / (CH / GRID_H));
  if (x < 0 || x >= GRID_W || y < 0 || y >= GRID_H) return null;
  return [x, y];
}

function paintCell(e) {
  const cell = getCellFromEvent(e);
  if (!cell) return;
  const [x, y] = cell;
  grid[y][x] = brush;
  render();
}

canvas.addEventListener('mousedown', e => {
  if (e.button === 2) return; // å³é”®å•ç‹¬å¤„ç†
  isDrawing = true;
  paintCell(e);
});
canvas.addEventListener('mousemove', e => {
  const cell = getCellFromEvent(e);
  hoverCell = cell;
  if (cell) {
    document.getElementById('coord-display').textContent = `x:${cell[0]} y:${cell[1]}`;
  }
  if (isDrawing) paintCell(e);
  else render();
});
canvas.addEventListener('mouseup', () => { isDrawing = false; });
canvas.addEventListener('mouseleave', () => {
  isDrawing = false;
  hoverCell = null;
  document.getElementById('coord-display').textContent = 'x:- y:-';
  render();
});
// å³é”®æ“¦é™¤
canvas.addEventListener('contextmenu', e => {
  e.preventDefault();
  const cell = getCellFromEvent(e);
  if (cell) { grid[cell[1]][cell[0]] = 0; render(); }
});

// â”€â”€ ç¬”åˆ·åˆ‡æ¢ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
document.querySelectorAll('.brush-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    brush = parseInt(btn.dataset.brush);
    document.querySelectorAll('.brush-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
  });
});

// é”®ç›˜å¿«æ·é”®
window.addEventListener('keydown', e => {
  if (e.key === '1') document.querySelector('[data-brush="1"]').click();
  if (e.key === '2') document.querySelector('[data-brush="2"]').click();
  if (e.key === 'e' || e.key === 'E' || e.key === '0') document.querySelector('[data-brush="0"]').click();
});

// â”€â”€ æ¸…ç©º â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
document.getElementById('clear-btn').addEventListener('click', () => {
  if (!confirm('æ¸…ç©ºæ‰€æœ‰æ ¼å­ï¼Ÿ')) return;
  grid = newGrid();
  render();
});

// â”€â”€ ç”Ÿæˆ JSON â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
document.getElementById('export-btn').addEventListener('click', () => {
  const traced = tracePathCells();
  const waypoints = toWaypoints(traced);

  const towerSpots = [];
  for (let y = 0; y < GRID_H; y++)
    for (let x = 0; x < GRID_W; x++)
      if (grid[y][x] === 2) towerSpots.push({ x, y });

  const levelId = currentLevel?.id ?? '(æœªé€‰æ‹©å…³å¡)';

  const output = {
    levelId,
    pathNodes: waypoints.map(([x, y]) => ({ x, y })),
    towerSpots,
  };

  const json = JSON.stringify(output, null, 2);
  document.getElementById('json-output').value = json;
});

// â”€â”€ å¤åˆ¶ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
document.getElementById('copy-btn').addEventListener('click', async () => {
  const text = document.getElementById('json-output').value;
  if (!text) return;
  try {
    await navigator.clipboard.writeText(text);
    const status = document.getElementById('copy-status');
    status.textContent = 'âœ… å·²å¤åˆ¶ï¼';
    setTimeout(() => { status.textContent = ''; }, 2000);
  } catch {
    document.getElementById('json-output').select();
    document.execCommand('copy');
  }
});

// â”€â”€ åˆå§‹æ¸²æŸ“ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
render();
</script>
</body>
</html>
